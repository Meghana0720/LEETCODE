/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {string[][]}
 */
var findLadders = function(beginWord, endWord, wordList) {
    let wordSet = new Set(wordList);
    if (!wordSet.has(endWord)) return [];

    let layer = new Map(); // Stores the transformation graph
    let found = false;
    let queue = new Set([beginWord]); // BFS queue
    wordSet.delete(beginWord);

    // BFS to build adjacency list
    while (queue.size > 0 && !found) {
        let nextLevel = new Set();
        for (let word of queue) {
            let wordArr = word.split("");
            for (let i = 0; i < wordArr.length; i++) {
                let originalChar = wordArr[i];
                for (let c = 97; c <= 122; c++) { // 'a' to 'z'
                    wordArr[i] = String.fromCharCode(c);
                    let newWord = wordArr.join("");
                    if (wordSet.has(newWord)) {
                        if (!layer.has(newWord)) {
                            layer.set(newWord, []);
                        }
                        layer.get(newWord).push(word);
                        nextLevel.add(newWord);
                        if (newWord === endWord) found = true;
                    }
                }
                wordArr[i] = originalChar; // Restore original letter
            }
        }
        queue = nextLevel;
        for (let word of queue) wordSet.delete(word); // Remove visited words
    }

    if (!found) return []; // If no path exists

    // DFS to construct shortest paths
    let res = [];
    function dfs(word, path) {
        if (word === beginWord) {
            res.push([beginWord, ...path.reverse()]);
            return;
        }
        if (layer.has(word)) {
            for (let prev of layer.get(word)) {
                dfs(prev, [...path, word]);
            }
        }
    }
    dfs(endWord, []);

    return res;
};
